#!/bin/busybox ash
# shellcheck shell=dash
# shellcheck disable=SC3057
# ash supports string indexing just fine shellcheck!

# This file is executed on boot to initialize the system and can also be run by
# the user to start/stop daemons.

# Note: Preferable to use a busybox with:
# FEATURE_SH_STANDALONE, FEATURE_PREFER_APPLETS, FEATURE_SH_NOFORK
# In NixOS the shebang is automatically rewritten to use one with these features
# Assume busybox ash shell features and prefer builtins or nofork applets

PATH="$PATH:/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin" # traditonal linux paths
PATH="$PATH:/usr/lib/systemd" # systemd libexec components normally hidden from PATH
PATH="$PATH:/run/current-system/sw/bin:/run/current-system/sw/sbin:/run/wrappers/bin" # NixOS standard path
PATH="$PATH:/run/current-system/sw/lib/systemd" # systemd libexec components in NixOS

# Fallback Configuration Values, to be able to run even with a broken, deleted
# or outdated minirc.conf:
DAEMONS="\
syslog-ng \
dbus \
acpid \
alsa \
crond \
iptables \
wpa_supplicant \
ntpd \
dhcpcd \
sshd \
vsftpd \
lighttpd \
privoxy \
polipo \
mpd \
haveged \
"

ENABLED="\
@dbus \
@alsa \
"

UDEV="auto"
NETWORK_INTERFACE="eth0"
WIFI_INTERFACE="wlan0"
WAIT_POLLRATE="0.1"
WAIT_TRIES="30"
read -r HOSTNAME </etc/hostname

main() {
	# handle arguments
	case "$1" in
	init)
		on_boot;;
	shutdown)
		on_shutdown;;
	start|stop|restart)
		cmd="$1"
		shift
		for dmn in ${@:-${DAEMONS}}; do
			daemon "${cmd}" "${dmn}"
		done;;
	''|list)
		# list all daemons and their status
		for dmn in ${DAEMONS}; do
			daemon exists "${dmn}" || continue
			if daemon poll "${dmn}"; then
				echo_color 2 [X] "${dmn}"
			else
				echo_color 0 [ ] "${dmn}"
			fi
		done;;
	--version)
		echo minirc 1.0;;
	*)
		self=$(basename "$0")
		echo "Usage: ${self} [--help] [--version] <action> [list of daemons]"
		echo
		echo "Actions:"
		echo "   ${self} list               shows status of all daemons (default action)"
		echo "   ${self} start [daemons]    starts daemons"
		echo "   ${self} stop [daemons]     stops daemons"
		echo "   ${self} restart [daemons]  restarts daemons";;
	esac
}

# Wait in default polling manner on a condition
wait_on() {
	for i in $(seq "${2:-${WAIT_TRIES}}"); do
		${1} && return 0
		sleep "${3:-${WAIT_POLLRATE}}"
	done
	echo "ERROR: Gave up waiting on condition ${1}! You should debug this to avoid wasting time in init!"
	return 1
}

on_boot() {
	# mount the API filesystem
	# /proc, /sys, /run, /dev, /run/lock, /dev/pts, /dev/shm
	echo_color 3 mounting API filesystem...
	mountpoint -q /proc  || mount -t proc proc /proc -o nosuid,noexec,nodev
	mountpoint -q /sys   || mount -t sysfs sys /sys -o nosuid,noexec,nodev
	mountpoint -q /run   || mount -t tmpfs run /run -o mode=0755,nosuid,nodev
	mountpoint -q /dev   || mount -t devtmpfs dev /dev -o mode=0755,nosuid
	mkdir -p /dev/pts /dev/shm
	mountpoint -q /dev/pts || mount -t devpts devpts /dev/pts -o mode=0620,gid=5,nosuid,noexec
	mountpoint -q /dev/shm || mount -t tmpfs shm /dev/shm -o mode=1777,nosuid,nodev
	mount -o remount,rw /
	
	# TODO: Rotate X number of logs, or timestamp?
	echo_color 3 logging init to /var/log/rc/initlog
	set -x
	mkdir -p /var/log/rc
	touch "/var/log/rc/initlog"
	exec 1>"/var/log/rc/initlog"
	exec 2>&1

	# initialize system
	echo_color 3 setting up loopback device...
	ip link set up dev lo

	# Consider modprobing these in case udev fails?
	#modprobe xhci_hcd
	#modprobe usbhid

	echo_color 3 initializing udev...
	if [ "${UDEV}" = "auto" ]; then
		if command -v systemctl >/dev/null 2>&1; then
			UDEV="systemd"
		elif command -v udevd >/dev/null 2>&1; then
			UDEV="eudev"
		else
			UDEV="busybox"
		fi
	fi
	if [ "${UDEV}" = "systemd" ]; then
		systemd-udevd --daemon
		udevadm trigger --action=add --type=subsystems
		udevadm trigger --action=add --type=devices
	elif [ "${UDEV}" = "eudev" ]; then
		udevd --daemon
		udevadm trigger --action=add --type=subsystems
		udevadm trigger --action=add --type=devices
	else # use busybox mdev as fallback:
		# TODO: hotplug might not exist. It's not a normally enabled feature anymore, CONFIG_UEVENT_HELPER enables it
		# TODO: Address "busybox" reference, might not be in PATH
		busybox mdev -s
		echo /sbin/mdev > /proc/sys/kernel/hotplug
	fi

	echo_color 3 setting hostname...
	echo "${HOSTNAME}" >| /proc/sys/kernel/hostname

	echo_color 3 setting fd link...	
	ln -s /proc/self/fd /dev/fd

	# start the default daemons
	echo_color 3 starting daemons...
	for dmn in ${ENABLED}; do
		if [ "${dmn:0:1}" = '@' ]; then
			daemon start "${dmn:1}" > "/var/log/rc/${dmn:1}" 2>&1 &
		else
			daemon start "${dmn}"
		fi
	done
	
	echo_color 3 mounting rest of filesystems...
	wait_on "mount -a"

	# load /etc/minirc.local
	if [ -x /etc/minirc.local ]; then
		echo_color 3 loading /etc/minirc.local...
		/etc/minirc.local
	fi
}

on_shutdown() {
	# stop the default daemons
	echo_color 3 stopping daemons...
	for dmn in ${ENABLED}; do
		if [ "${dmn:0:1}" = '@' ]; then
			daemon stop "${dmn:1}" &
		else
			daemon stop "${dmn}"
		fi
	done

	# load minirc.local.shutdown
	if [ -x /etc/minirc.local.shutdown ]; then
		echo_color 3 loading /etc/minirc.local.shutdown...
		/etc/minirc.local.shutdown
	fi

	# shut down udev
	echo_color 3 shutting down udev...
	if [ "${UDEV}" = systemd ]; then
		killall systemd-udevd
	elif [ "${UDEV}" = eudev ]; then
		killall udevd
	fi

	# umount the API filesystem
	echo_color 3 unmounting API filesystem...
	umount -r /run
}

# daemon [start/stop/restart/poll/exists] service_name
daemon() {
	case "${1}" in
		start)
			echo_color 2 starting "$2"...
			;;
		stop)
			echo_color 1 stopping "$2"...
			;;
		restart)
			;;
		poll)
			;;
		exists)
			;;
	esac
	
	if command -v "${2}"_"${1}" >/dev/null 2>&1; then
		"${2}"_"${1}"
	else
		default_"${1}" "${2}"
	fi
}

default_start() {
	"${1}"
}

default_stop() {
	killall "${1}"
}

default_restart() {
	daemon stop "${1}"
	daemon start "${1}"
}

default_poll() {
	pgrep "(^|/)${1}\$" >/dev/null 2>&1
}

default_exists() {
	command -v "${1}" >/dev/null 2>&1
}

alsa_start() {
	if wait_on "[ -c /dev/snd/controlC0 ]"; then
		alsactl restore || alsactl --no-lock restore
		return
	fi
	return 0
}

alsa_stop() {
	mkdir -p /var/lib/alsa
	alsactl store || alsactl --no-lock store
}

alsa_poll() {
	return 1
}

alsa_exists() {
	# Don't list sysinit actions
	return 1
}

bitlbee_start() {
	su -s /bin/sh -c 'bitlbee -F' bitlbee
}

dbus_start() {
	mkdir -p /run/dbus
	dbus-uuidgen --ensure
	dbus-daemon --system
}

dbus_stop() {
	killall dbus-launch
	killall dbus-daemon
	rm /run/dbus/pid
}

dbus_poll() {
	test -e /run/dbus/pid
}

upowerd_start() {
	wait_on dbus_poll
	# Let dbus start upowerd by invoking upower, not normally available in PATH
	upower
}

# Hyphens are not supported in function names, so can't use 'systemd-tmpfiles'
tmpfiles_start() {
	systemd-tmpfiles --create --remove --boot
}

tmpfiles_stop() {
	systemd-tmpfiles --clean
}

tmpfiles_poll() {
	return 1
}

tmpfiles_exists() {
	return 1
}

# The defaults do fine for this daemon, but just naming it would cause
# confusion for overrides since the hyphen can't be used in function names :(
nixdaemon_start() {
	default_start "nix-daemon"
}

nixdaemon_stop() {
	default_stop "nix-daemon"
}

nixdaemon_poll() {
	default_poll "nix-daemon"
}

nixdaemon_exists() {
	default_exists "nix-daemon"
}

# User daemon, start for all human users
pulseaudio_start() {
	pulseaudio --system --daemonize=true
}

iptables_start() {
	if [ -f /etc/iptables/iptables.rules ]; then
		iptables-restore < /etc/iptables/iptables.rules
	fi
}

iptables_stop() {
	for table in $(cat /proc/net/ip_tables_names); do
		iptables-restore < /var/lib/iptables/empty-"$table".rules
	done
}

iptables_poll() {
	sudo iptables -L -n | grep -m 1 -q '^ACCEPT\|^REJECT' >/dev/null 2>&1
}

sshd_start() {
	eval "$(command -v sshd)"  # sshd requires an absolute path, so grab path from command -v
}

sshd_restart() {
	# Make sure minirc doesn't hang up when restarting it remotely
	# TODO: Address "busybox" reference, might not be in PATH
	busybox setsid sh -c '"$0" stop "$@"; "$0" start "$@"' "$0" "$@"
}

privocy_start() {
	privoxy --user privoxy.privoxy /etc/privoxy/config
}

polipo_start() {
	su -c 'polipo daemonise=true logFile="/var/log/polipo.log"' -s /bin/sh - nobody
}

dhcpdc_start() {
	if ip link | grep -Fq ${NETWORK_INTERFACE}; then :; else
		echo_color 3 "waiting for ${NETWORK_INTERFACE} to settle..."
		wait_on "ip link | grep -Fq ${NETWORK_INTERFACE}"
	fi
	dhcpcd -nqb
}

vsftpd_start() {
	vsftpd &
}

lighttpd_start() {
	lighttpd -f /etc/lighttpd/lighttpd.conf
}

ntpd_start() {
	ntpd -g -u ntp
}

wpa_supplicant_start() {
	wait_on "iwconfig ${WIFI_INTERFACE}"
	wpa_supplicant -Dwext -B -i"${WIFI_INTERFACE}" -c/etc/wpa_supplicant.conf
}

icecast_start() {
	icecast -b -c /etc/icecast.xml
}

echo_color() {
	color="$1"
	shift
	printf "\033[1;3%sm%s\033[00m\n" "${color}" "$*"
}

if [ -r /etc/minirc.conf ]; then
	. /etc/minirc.conf
fi

main $@
